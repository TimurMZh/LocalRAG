# Философия проектирования и обсуждение

## Почему DAG вместо циклических агентных рабочих процессов

Наш выбор направленных ациклических графов (DAG) вместо циклических агентных рабочих процессов основан на многолетнем практическом опыте создания AI систем. Хотя AI сообщество проявляет большой интерес к автономным агентам, мы обнаружили, что рабочие процессы на основе DAG по-прежнему предлагают несколько важных преимуществ:

1. **Предсказуемое выполнение**: DAG гарантируют, что мы всегда можем отследить и предсказать путь выполнения любого рабочего процесса. Эта предсказуемость критически важна для производственных систем, где надежность является обязательной.

2. **Отладка**: Когда что-то идет не так (а это случится), системы на основе DAG позволяют легко определить, где и почему произошла ошибка. Входные и выходные данные каждого узла четко определены и сохранены.

3. **Сопровождаемость**: Новые члены команды могут быстро понять логику рабочего процесса, следуя четко определенным путям через систему. Нет скрытого состояния или сложных шаблонов взаимодействия для расшифровки.

За годы создания AI систем мы не встретили проблемы, которую нельзя было бы решить с помощью этого паттерна. Даже сложные, казалось бы циклические рабочие процессы можно смоделировать как серию детерминированных шагов при правильном анализе.

## Расширяемость и интеграция

Базовая система Репозитория намеренно спроектирована как адаптируемая и расширяемая. Хотя она отлично работает как есть, вы можете:

1. **Интегрироваться с другими движками рабочих процессов**:
```python
# Example: Using with Prefect
from prefect import flow

@flow
def my_prefect_flow(event_data):
    # Create pipeline
    pipeline = MyCustomPipeline()
    
    # Process event
    result = pipeline.run(event_data)
    
    # Store results
    store_results(result)
```

2. **Расширить базовые компоненты**:
```python
# Пример: Расширенный TaskContext
class EnhancedTaskContext(TaskContext):
    audit_trail: List[Dict] = Field(default_factory=list)
    
    def log_action(self, action: str, metadata: Dict):
        self.audit_trail.append({
            "action": action,
            "timestamp": datetime.now(),
            "metadata": metadata
        })
```

3. **Логика пользовательской валидации**:
```python
class CustomPipelineValidator(PipelineValidator):
    def validate(self):
        super().validate()
        self._validate_custom_rules()
    
    def _validate_custom_rules(self):
        # Add your custom validation logic
        pass
```

## Адаптивность к будущему

Хотя этот подход хорошо служил нам, мы признаем, что область AI быстро развивается. По мере развития языковых моделей и архитектур агентов нам может потребоваться адаптировать наши паттерны. Однако фундаментальные принципы:

- Четкий поток данных
- Предсказуемое выполнение
- Управление состоянием
- Обработка ошибок

Останутся ценными независимо от того, как развивается технология.

## Базовый паттерн: Chain of Responsibility

Вся система основана на паттерне Chain of Responsibility, о котором вы можете узнать больше на [Refactoring Guru's Chain of Responsibility Pattern](https://refactoring.guru/design-patterns/chain-of-responsibility). Этот паттерн обеспечивает:

```python
# Пример Chain of Responsibility в действии
class Pipeline:
    def run(self, event: EventSchema) -> TaskContext:
        context = TaskContext(event=event)
        
        # Each node in the chain processes and passes along
        for node in self.get_node_sequence():
            context = node.process(context)
            
        return context
```
Этот паттерн обеспечивает:

- Четкое разделение ответственности
- Простое добавление новых этапов обработки
- Гибкую логику маршрутизации
- Поддерживаемую кодовую базу

## Практические соображения

При адаптации базовой системы под ваши нужды:

1. **Начните с малого**: Начните с базовой реализации и расширяйте по мере необходимости.
2. **Документируйте изменения**: Отслеживайте модификации базовых компонентов.
3. **Сохраняйте принципы**: Даже при кастомизации сохраняйте основные принципы потока на основе DAG и четкого управления состоянием.
4. **Тщательно тестируйте**: Изменения в базовых компонентах должны быть хорошо протестированы для обеспечения надежности системы.