# База данных и миграции

Репозиторий использует PostgreSQL в качестве основного хранилища данных, с Alembic для управления миграциями базы данных. Такая настройка обеспечивает надежную основу для хранения и обработки событий, сохраняя при этом гибкость схемы через JSON колонки.

## Архитектура базы данных

### Модель хранения событий

Ядром нашего дизайна базы данных является модель Event, которая реализует гибкую схему для хранения как входящих событий, так и результатов их обработки:

```python
class Event(Base):
    __tablename__ = "events"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid1)
    data = Column(JSON)              # Raw event data
    task_context = Column(JSON)      # Processing results
    created_at = Column(DateTime)    # Event creation timestamp
    updated_at = Column(DateTime)    # Last update timestamp
```
Такой дизайн обеспечивает:

- Уникальную идентификацию каждого события через UUID
- Гибкое хранение любого типа события через JSON колонки 
- Автоматическое отслеживание временных меток
- Удобный запрос как исходных данных, так и результатов обработки

## Repository Pattern

Мы реализуем паттерн репозитория для абстрагирования операций с базой данных и предоставления чистого интерфейса для доступа к данным:

```python
class GenericRepository(Generic[T]):
    def __init__(self, session: Session, model: Type[T]):
        self.session = session
        self.model = model

    def create(self, obj: T) -> T:
        self.session.add(obj)
        self.session.commit()
        return obj
```
Этот паттерн обеспечивает:

- Type-safe операции с базой данных
- Согласованную обработку ошибок
- Управление транзакциями
- Переиспользуемые CRUD операции

## Управление сессиями

Сессии базы данных управляются через паттерн внедрения зависимостей:

```python
def db_session() -> Generator:
    session: Session = SessionLocal()
    try:
        yield session
        session.commit()
    except Exception:
        session.rollback()
        raise
    finally:
        session.close()
```
Это обеспечивает:

- Правильную обработку соединений
- Автоматическое управление транзакциями  
- Очистку ресурсов
- Пулинг соединений

## Миграции базы данных с помощью Alembic

Alembic - это легковесный инструмент миграции баз данных для Python, разработанный для работы с SQLAlchemy, популярным SQL тулкитом и библиотекой объектно-реляционного отображения (ORM).

- Контроль версий схем базы данных: Alembic отслеживает различные версии схемы вашей базы данных, позволяя обновлять или откатывать к любой версии по необходимости.
- Генерация скриптов миграции: Он может автоматически генерировать скрипты миграции, сравнивая текущую схему базы данных с вашими моделями SQLAlchemy. Эти скрипты описывают изменения, которые нужно применить, такие как добавление новой таблицы или изменение столбца.
- Согласованное применение миграций: Использование Alembic гарантирует, что все разработчики проекта применяют изменения базы данных в одинаковом порядке и способе, уменьшая расхождения между средами разработки.
- Интеграция с CI/CD пайплайнами: Alembic может быть включен в рабочие процессы непрерывной интеграции и развертывания для автоматизации миграций базы данных при деплое.

### Ключевые компоненты

- Скрипты миграции: Python файлы, детализирующие конкретные изменения в схеме базы данных.
- Интерфейс командной строки: Инструменты для создания новых миграций, применения существующих и управления историей миграций.
- Конфигурационный файл: Определяет строки подключения и настройки Alembic, обычно называется alembic.ini.

### Архитектура миграций

Alembic управляет эволюцией схемы базы данных через версионированные скрипты миграции. Наша настройка использует автогенерацию для поддержания миграций на основе моделей SQLAlchemy.

### Конфигурация миграций

Среда Alembic настраивается в `env.py`:

```python
from database.session import Base
from database.event import *  # Required for autogeneration

target_metadata = Base.metadata

config.set_main_option(
    "sqlalchemy.url", 
    DatabaseUtils.get_connection_string()
)
```
### Процесс миграции

1. **Создание миграций**
   ```bash
   ./makemigration.sh
   ```
   Этот скрипт:
   - Обнаруживает изменения в моделях
   - Генерирует новый файл миграции
   - Добавляет его в систему контроля версий

2. **Применение миграций**
   ```bash
   ./migrate.sh
   ```
   Этот скрипт:
   - Проверяет текущую версию базы данных
   - Применяет ожидающие миграции
   - Обновляет отслеживание версий

### Лучшие практики миграций

1. **Контроль версий**
   - Все миграции находятся под контролем версий
   - Файлы миграций рассматриваются как код
   - Никогда не модифицируйте существующие миграции

2. **Тестирование**
   - Тестируйте миграции на копии производственных данных
   - Включайте пути обновления и отката
   - Проверяйте целостность данных после миграции

3. **Развертывание**
   - Запускайте миграции перед развертыванием нового кода
   - Делайте резервную копию базы данных перед миграцией
   - Используйте обертку транзакций для безопасности

## Утилиты базы данных

Класс DatabaseUtils обеспечивает централизованную конфигурацию базы данных:

```python
class DatabaseUtils:
    @staticmethod
    def get_connection_string():
        return f"postgresql://{db_user}:{db_password}@{db_host}:{db_port}/{db_name}"
```
Это обеспечивает:

- Согласованное форматирование строки подключения
- Конфигурацию на основе окружения
- Единый источник истины для настроек базы данных

## Соображения безопасности

1. **Безопасность подключения**
   - SSL/TLS шифрование для подключений
   - Строгие политики паролей
   - Ограничения пула подключений

2. **Безопасность данных**
   - Валидация JSON перед сохранением
   - Санитизация входных данных
   - Контроль доступа через слой репозитория

3. **Операционная безопасность**
   - Регулярное резервное копирование
   - Возможности отката миграций
   - Изоляция транзакций

## Оптимизация производительности

1. **Стратегия индексирования**
   - Оптимизация первичного ключа UUID
   - Индексирование JSON колонок для частых запросов
   - Индексирование временных меток для запросов на основе времени

2. **Оптимизация запросов**
   - Эффективные JSON операторы
   - Prepared statements
   - Connection pooling

## Расширение базы данных

Чтобы добавить новые модели:

1. Создайте новый класс модели:

```python
class CustomModel(Base):
    __tablename__ = "custom_models"
    id = Column(UUID(as_uuid=True), primary_key=True)
    # Add custom fields
```

2. Создайте миграцию:

```bash
./makemigration.sh "add_custom_model"
```

3. Примените миграцию:

```bash
./migrate.sh
```

Модульный дизайн делает расширение базы данных простым, сохраняя при этом целостность данных и историю миграций.